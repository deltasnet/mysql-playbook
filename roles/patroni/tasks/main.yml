---

- name: Make sure handlers are flushed immediately
  ansible.builtin.meta: flush_handlers

# pip install
- ansible.builtin.import_tasks: pip.yml
  when:
    - Orchestrator_installation_method == "pip"
    - system_packages is not search("python3-pip")
  tags: Orchestrator, Orchestrator_install, pip

# Orchestrator install
- block:  # installation_method: "repo" and Orchestrator_installation_method: "pip"
    - name: Copy Orchestrator requirements.txt file
      ansible.builtin.copy:
        src: requirements.txt
        dest: /tmp/requirements.txt
      when: Orchestrator_pip_requirements_repo | length < 1

    - name: Install setuptools
      ansible.builtin.pip:
        name: setuptools<66.0.0  # https://github.com/pypa/setuptools/issues/3772
        state: latest
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_requirements_repo | length < 1

    - name: Install requirements
      ansible.builtin.pip:
        requirements: /tmp/requirements.txt
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:{{ MySQL_bin_dir }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_requirements_repo | length < 1

    - name: Install Orchestrator
      ansible.builtin.pip:
        name: Orchestrator
        state: latest
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_package_repo | length < 1 and Orchestrator_install_version == "latest"

    - name: "Install Orchestrator {{ Orchestrator_install_version }}"
      ansible.builtin.pip:
        name: "Orchestrator=={{ Orchestrator_install_version }}"
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_package_repo | length < 1 and Orchestrator_install_version != "latest"
  when: installation_method == "repo" and Orchestrator_installation_method == "pip"
  environment: "{{ proxy_env | default({}) }}"
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tags: Orchestrator, Orchestrator_install

- block:  # when "Orchestrator_pip_requirements_repo" and "Orchestrator_pip_package_repo" is defined
    - name: Download Orchestrator requirements
      ansible.builtin.get_url:
        url: "{{ item }}"
        dest: /tmp/
        timeout: 120
        validate_certs: false
      loop: "{{ Orchestrator_pip_requirements_repo }}"
      when: Orchestrator_pip_requirements_repo | length > 0

    - name: Download Orchestrator package
      ansible.builtin.get_url:
        url: "{{ item }}"
        dest: /tmp/
        timeout: 60
        validate_certs: false
      loop: "{{ Orchestrator_pip_package_repo | list }}"
      when: Orchestrator_pip_package_repo | length > 0

    - name: Install requirements
      ansible.builtin.pip:
        name: "file:///tmp/{{ item }}"
        executable: pip3
        extra_args: "--no-index --find-links=file:///tmp --ignore-installed"
        umask: "0022"
      loop: "{{ Orchestrator_pip_requirements_repo | map('basename') | list }}"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_requirements_repo | length > 0

    - name: Install Orchestrator
      ansible.builtin.pip:
        name: "file:///tmp/{{ item }}"
        executable: pip3
        extra_args: "--no-index --find-links=file:///tmp --ignore-installed"
        umask: "0022"
      loop: "{{ Orchestrator_pip_package_repo | map('basename') | list }}"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_package_repo | length > 0
  when: installation_method == "repo" and Orchestrator_installation_method == "pip"
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tags: Orchestrator, Orchestrator_install

- block:  # installation_method: "file" and Orchestrator_installation_method: "pip"
    - name: Copy Orchestrator requirements
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: /tmp/
      loop: "{{ Orchestrator_pip_requirements_file }}"
      when: Orchestrator_pip_requirements_file | length > 0

    - name: Copy Orchestrator package
      ansible.builtin.copy:
        src: "{{ item }}"
        dest: /tmp/
      loop: "{{ Orchestrator_pip_package_file }}"
      when: Orchestrator_pip_package_file | length > 0

    - name: Install requirements
      ansible.builtin.pip:
        name: "file:///tmp/{{ item }}"
        executable: pip3
        extra_args: "--no-index --find-links=file:///tmp --ignore-installed"
        umask: "0022"
      loop: "{{ Orchestrator_pip_requirements_file | map('basename') | list }}"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_requirements_file | length > 0

    - name: Install Orchestrator
      ansible.builtin.pip:
        name: "file:///tmp/{{ item }}"
        executable: pip3
        extra_args: "--no-index --find-links=file:///tmp --ignore-installed"
        umask: "0022"
      loop: "{{ Orchestrator_pip_package_file | map('basename') | list }}"
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      when: Orchestrator_pip_package_file | length > 0
  when: installation_method == "file" and Orchestrator_installation_method == "pip"
  vars:
    ansible_python_interpreter: /usr/bin/python3
  tags: Orchestrator, Orchestrator_install

- block:  # installation_method: "repo" and Orchestrator_installation_method: "rpm/deb"
    # Debian
    - name: Install Orchestrator package
      ansible.builtin.package:
        name: "{{ Orchestrator_packages | default('Orchestrator') }}"
        state: present
      register: package_status
      until: package_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "Debian" and Orchestrator_deb_package_repo | length < 1

    # RedHat
    - name: Install Orchestrator package
      ansible.builtin.package:
        name: "{{ Orchestrator_packages | default('Orchestrator') }}"
        state: present
      register: package_status
      until: package_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "RedHat" and Orchestrator_rpm_package_repo | length < 1

    # when Orchestrator_deb_package_repo or Orchestrator_rpm_package_repo URL is defined
    # Debian
    - name: Download Orchestrator deb package
      ansible.builtin.get_url:
        url: "{{ item }}"
        dest: /tmp/
        timeout: 60
        validate_certs: false
      loop: "{{ Orchestrator_deb_package_repo | list }}"
      when: ansible_os_family == "Debian" and Orchestrator_deb_package_repo | length > 0

    - name: Install Orchestrator from deb package
      ansible.builtin.apt:
        force_apt_get: true
        deb: "/tmp/{{ item }}"
        state: present
      loop: "{{ Orchestrator_deb_package_repo | map('basename') | list }}"
      register: apt_status
      until: apt_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "Debian" and Orchestrator_deb_package_repo | length > 0

    # RedHat
    - name: Download Orchestrator rpm package
      ansible.builtin.get_url:
        url: "{{ item }}"
        dest: /tmp/
        timeout: 60
        validate_certs: false
      loop: "{{ Orchestrator_rpm_package_repo | list }}"
      when: ansible_os_family == "RedHat" and Orchestrator_rpm_package_repo | length > 0

    - name: Install Orchestrator from rpm package
      ansible.builtin.package:
        name: "/tmp/{{ item }}"
        state: present
      loop: "{{ Orchestrator_rpm_package_repo | map('basename') | list }}"
      register: package_status
      until: package_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "RedHat" and Orchestrator_rpm_package_repo | length > 0
  environment: "{{ proxy_env | default({}) }}"
  when: installation_method == "repo" and (Orchestrator_installation_method == "rpm" or Orchestrator_installation_method == "deb")
  tags: Orchestrator, Orchestrator_install

# installation_method: "file" and Orchestrator_installation_method: "rpm/deb"
- block:
    # Debian
    - name: Copy Orchestrator deb package into /tmp
      ansible.builtin.copy:
        src: "{{ Orchestrator_deb_package_file }}"
        dest: /tmp/
      when: ansible_os_family == "Debian"

    - name: Install Orchestrator from deb package
      ansible.builtin.apt:
        force_apt_get: true
        deb: "/tmp/{{ Orchestrator_deb_package_file | basename }}"
        state: present
      register: apt_status
      until: apt_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "Debian"

    # RedHat
    - name: Copy Orchestrator rpm package into /tmp
      ansible.builtin.copy:
        src: "{{ Orchestrator_rpm_package_file }}"
        dest: /tmp/
      when: ansible_os_family == "RedHat"

    - name: Install Orchestrator from rpm package
      ansible.builtin.package:
        name: "/tmp/{{ Orchestrator_rpm_package_file | basename }}"
        state: present
      register: package_status
      until: package_status is success
      delay: 5
      retries: 3
      when: ansible_os_family == "RedHat"
  when: installation_method == "file" and (Orchestrator_installation_method == "rpm" or Orchestrator_installation_method == "deb")
  tags: Orchestrator, Orchestrator_install

# Orchestrator configure
- name: Create conf directory
  ansible.builtin.file:
    path: /etc/Orchestrator
    state: directory
    owner: postgres
    group: postgres
    mode: "0750"
  tags: Orchestrator, Orchestrator_conf

- name: Generate conf file "/etc/Orchestrator/Orchestrator.yml"
  ansible.builtin.template:
    src: templates/Orchestrator.yml.j2
    dest: /etc/Orchestrator/Orchestrator.yml
    owner: postgres
    group: postgres
    mode: "0640"
  when: existing_pgcluster is not defined or not existing_pgcluster|bool
  tags: Orchestrator, Orchestrator_conf

- name: Create Orchestrator log directory
  ansible.builtin.file:
    path: "{{ Orchestrator_log_dir }}"
    owner: postgres
    group: postgres
    state: directory
    mode: "0750"
  when: Orchestrator_log_destination == 'logfile'
  tags: Orchestrator, Orchestrator_conf

- block:  # for add_pgnode.yml
    - name: Fetch Orchestrator.yml conf file from master
      run_once: true
      ansible.builtin.fetch:
        src: /etc/Orchestrator/Orchestrator.yml
        dest: files/Orchestrator.yml
        validate_checksum: true
        flat: true
      delegate_to: "{{ groups.master[0] }}"

    - name: Copy Orchestrator.yml conf file to replica
      ansible.builtin.copy:
        src: files/Orchestrator.yml
        dest: /etc/Orchestrator/Orchestrator.yml
        owner: postgres
        group: postgres
        mode: "0640"

    - name: Remove Orchestrator.yml conf files from localhost
      become: false
      run_once: true
      ansible.builtin.file:
        path: files/Orchestrator.yml
        state: absent
      delegate_to: localhost

    - name: Prepare Orchestrator.yml conf file (replace "name","listen","connect_address")
      ansible.builtin.lineinfile:
        path: /etc/Orchestrator/Orchestrator.yml
        regexp: "{{ Orchestrator_config_without_cluster_vip_item.regexp }}"
        line: "{{ Orchestrator_config_without_cluster_vip_item.line }}"
        backrefs: true
      loop:
        - regexp: '^name:'
          line: 'name: {{ ansible_hostname }}'
        - regexp: '^  listen: .*:{{ Orchestrator_restapi_port }}$'
          line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ Orchestrator_restapi_port }}'
        - regexp: '^  connect_address: .*:{{ Orchestrator_restapi_port }}$'
          line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ Orchestrator_restapi_port }}'
        - regexp: '^  listen: ((?!{{ Orchestrator_restapi_port }}).)*$'
          line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }},127.0.0.1:{{ MySQL_port }}'
        - regexp: '^  connect_address: ((?!{{ Orchestrator_restapi_port }}).)*$'
          line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ MySQL_port }}'
      loop_control:
        loop_var: Orchestrator_config_without_cluster_vip_item
        label: "{{ Orchestrator_config_without_cluster_vip_item.line }}"
      when: with_haproxy_load_balancing|bool or pgbouncer_install|bool or (cluster_vip is not defined or cluster_vip | length < 1)

    - name: Prepare Orchestrator.yml conf file (replace "name","listen","connect_address")
      ansible.builtin.lineinfile:
        path: /etc/Orchestrator/Orchestrator.yml
        regexp: "{{ Orchestrator_config_with_cluster_vip_item.regexp }}"
        line: "{{ Orchestrator_config_with_cluster_vip_item.line }}"
        backrefs: true
      loop:
        - regexp: '^name:'
          line: 'name: {{ ansible_hostname }}'
        - regexp: '^  listen: .*:{{ Orchestrator_restapi_port }}$'
          line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ Orchestrator_restapi_port }}'
        - regexp: '^  connect_address: .*:{{ Orchestrator_restapi_port }}$'
          line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ Orchestrator_restapi_port }}'
        - regexp: '^  listen: ((?!{{ Orchestrator_restapi_port }}).)*$'
          line: '  listen: {{ hostvars[inventory_hostname].inventory_hostname }},{{ cluster_vip }},127.0.0.1:{{ MySQL_port }}'
        - regexp: '^  connect_address: ((?!{{ Orchestrator_restapi_port }}).)*$'
          line: '  connect_address: {{ hostvars[inventory_hostname].inventory_hostname }}:{{ MySQL_port }}'
      loop_control:
        loop_var: Orchestrator_config_with_cluster_vip_item
        label: "{{ Orchestrator_config_with_cluster_vip_item.line }}"
      when: not with_haproxy_load_balancing|bool and not pgbouncer_install|bool and (cluster_vip is defined and cluster_vip | length > 0)
  when: existing_pgcluster is defined and existing_pgcluster|bool
  tags: Orchestrator, Orchestrator_conf

- name: Copy systemd service file "/etc/systemd/system/Orchestrator.service"
  ansible.builtin.template:
    src: templates/Orchestrator.service.j2
    dest: /etc/systemd/system/Orchestrator.service
    owner: postgres
    group: postgres
    mode: "0644"
  tags: Orchestrator, Orchestrator_conf, Orchestrator_service

- name: Prepare MySQL | create statistics directory (if not already exists)
  ansible.builtin.file:
    path: "{{ MySQL_stats_temp_directory_path }}"
    state: directory
    mode: "01777"
  when:
    - MySQL_stats_temp_directory_path is defined
    - MySQL_stats_temp_directory_path != 'none'
    - MySQL_version is version('14', '<=')
  tags: Orchestrator, pgsql_stats_tmp

- name: Prepare MySQL | mount the statistics directory in memory (tmpfs)
  ansible.posix.mount:
    path: "{{ MySQL_stats_temp_directory_path }}"
    src: tmpfs
    fstype: tmpfs
    opts: "size={{ MySQL_stats_temp_directory_size }},uid=postgres,gid=postgres"
    state: mounted
  when:
    - MySQL_stats_temp_directory_path is defined
    - MySQL_stats_temp_directory_path != 'none'
    - MySQL_version is version('14', '<=')
  tags: Orchestrator, pgsql_stats_tmp

- name: Prepare MySQL | make sure the MySQL log directory "{{ MySQL_log_dir }}" exists
  ansible.builtin.file:
    path: "{{ MySQL_log_dir }}"
    owner: postgres
    group: postgres
    state: directory
    mode: "0700"
  tags: Orchestrator

- name: Prepare MySQL | make sure the custom WAL directory "{{ MySQL_wal_dir }}" exists
  ansible.builtin.file:
    path: "{{ MySQL_wal_dir }}"
    owner: postgres
    group: postgres
    state: directory
    mode: "0700"
  when: MySQL_wal_dir is defined and MySQL_wal_dir | length > 0
  tags: Orchestrator, custom_wal_dir

- block:  # wheh MySQL NOT exists or PITR
    - name: Prepare MySQL | make sure MySQL data directory "{{ MySQL_data_dir }}" exists
      ansible.builtin.file:
        path: "{{ MySQL_data_dir }}"
        owner: postgres
        group: postgres
        state: directory
        mode: "0700"

      # for Debian based distros only
      # Orchestrator bootstrap failure is possible if the MySQL config files are missing
    - name: Prepare MySQL | make sure the MySQL config files exists
      ansible.builtin.stat:
        path: "{{ MySQL_conf_dir }}/MySQL.conf"
      register: MySQL_conf_file
      when: ansible_os_family == "Debian" and
            MySQL_packages|join(" ") is not search("postgrespro")

    - name: Prepare MySQL | generate default MySQL config files
      become: true
      become_user: postgres
      ansible.builtin.command: >
        /usr/bin/pg_createcluster {{ MySQL_version }} {{ MySQL_cluster_name }}
        -d {{ MySQL_data_dir }}
        -p {{ MySQL_port }}
        -e {{ MySQL_encoding }}
        --locale {{ MySQL_locale }}
      register: pg_createcluster_result
      failed_when: pg_createcluster_result.rc != 0
      when: (ansible_os_family == "Debian" and
            MySQL_packages|join(" ") is not search("postgrespro")) and
            not MySQL_conf_file.stat.exists

    - name: Prepare MySQL | make sure the data directory "{{ MySQL_data_dir }}" is empty
      ansible.builtin.file:
        path: "{{ MySQL_data_dir }}"
        state: "{{ item }}"
        owner: postgres
        group: postgres
        mode: "0700"
      loop:
        - absent
        - directory
      when: (is_master | bool and Orchestrator_cluster_bootstrap_method != "pgbackrest")
            or (not is_master | bool and 'pgbackrest' not in Orchestrator_create_replica_methods)  # --delta restore

    - name: Prepare MySQL | make sure the custom WAL directory "{{ MySQL_wal_dir }}" is empty
      ansible.builtin.file:
        path: "{{ MySQL_wal_dir }}"
        state: "{{ item }}"
        owner: postgres
        group: postgres
        mode: "0700"
      loop:
        - absent
        - directory
      when: (MySQL_wal_dir is defined and MySQL_wal_dir | length > 0) and
            ((is_master | bool and Orchestrator_cluster_bootstrap_method != "pgbackrest")
              or (not is_master | bool and 'pgbackrest' not in Orchestrator_create_replica_methods))  # --delta restore
  when: not MySQL_exists | bool or Orchestrator_cluster_bootstrap_method != "initdb"
  tags: Orchestrator, point_in_time_recovery

- block:  # when MySQL exists
    - block:  # for master only
        - name: Prepare MySQL | check MySQL is started on Master
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl status -D {{ MySQL_data_dir }}"
          register: pg_ctl_status_result
          changed_when: false
          failed_when:
            - pg_ctl_status_result.rc != 0
            - pg_ctl_status_result.rc != 3

          # "Debian"
        - name: Prepare MySQL | start MySQL on Master
          become: true
          become_user: postgres
          ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ MySQL_version }} {{ MySQL_cluster_name }} start"
          register: pg_start_on_master
          when: pg_ctl_status_result.rc == 3 and
                (ansible_os_family == "Debian" and MySQL_packages|join(" ") is not search("postgrespro"))

          # "RedHat" or PostgresPro
        - name: Prepare MySQL | start MySQL on Master
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl start -D {{ MySQL_data_dir }}"
          register: pg_start_on_master
          when: pg_ctl_status_result.rc == 3 and
                (ansible_os_family == "RedHat" or MySQL_packages|join(" ") is search("postgrespro"))

        - name: Prepare MySQL | check MySQL is accepting connections
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_isready -p {{ MySQL_port }}"
          register: pg_isready_result
          until: pg_isready_result.rc == 0
          retries: 30
          delay: 10
          changed_when: false

        - name: Prepare MySQL | generate pg_hba.conf on Master
          ansible.builtin.template:
            src: templates/pg_hba.conf.j2
            dest: "{{ MySQL_conf_dir }}/pg_hba.conf"
            owner: postgres
            group: postgres
            mode: "0640"

        - name: Prepare MySQL | reload for apply the pg_hba.conf
          become: true
          become_user: postgres
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl reload -D {{ MySQL_data_dir }}"

        - name: Prepare MySQL | make sure the user "{{ Orchestrator_superuser_username }}" are present, and password does not differ from the specified
          community.MySQL.MySQL_user:
            db: postgres
            name: "{{ Orchestrator_superuser_username }}"
            password: "{{ Orchestrator_superuser_password }}"
            encrypted: true
            role_attr_flags: "SUPERUSER"
            login_unix_socket: "{{ MySQL_unix_socket_dir }}"
            port: "{{ MySQL_port }}"
            state: present
          become: true
          become_user: postgres

        - name: Prepare MySQL | make sure the user "{{ Orchestrator_replication_username }}" are present, and password does not differ from the specified
          community.MySQL.MySQL_user:
            db: postgres
            name: "{{ Orchestrator_replication_username }}"
            password: "{{ Orchestrator_replication_password }}"
            encrypted: true
            role_attr_flags: "LOGIN,REPLICATION"
            login_unix_socket: "{{ MySQL_unix_socket_dir }}"
            port: "{{ MySQL_port }}"
            state: present
          become: true
          become_user: postgres
      when: is_master | bool

    - name: Prepare MySQL | check MySQL is started
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl status -D {{ MySQL_data_dir }}"
      register: pg_ctl_status_result
      changed_when: false
      failed_when:
        - pg_ctl_status_result.rc != 0
        - pg_ctl_status_result.rc != 3

    - name: Prepare MySQL | waiting for CHECKPOINT to complete before stopping MySQL
      become: true
      become_user: postgres
      ansible.builtin.command: >
        {{ MySQL_bin_dir }}/psql -p {{ MySQL_port }} -U {{ Orchestrator_superuser_username }} -d postgres -tAXc "CHECKPOINT"
      register: checkpoint_result
      until: checkpoint_result.rc == 0
      retries: 300
      delay: 10
      when: pg_ctl_status_result.rc == 0

      # "Debian"
    - name: Prepare MySQL | stop MySQL (will be managed by Orchestrator)
      become: true
      become_user: postgres
      ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ MySQL_version }} {{ MySQL_cluster_name }} stop -m fast -- -w -t 600"
      when: (checkpoint_result.rc is defined and checkpoint_result.rc == 0) and
            (ansible_os_family == "Debian" and MySQL_packages|join(" ") is not search("postgrespro"))

      # "RedHat" or PostgresPro
    - name: Prepare MySQL | stop MySQL (will be managed by Orchestrator)
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl stop -D {{ MySQL_data_dir }} -m fast -w -t 600"
      when: (checkpoint_result.rc is defined and checkpoint_result.rc == 0) and
            (ansible_os_family == "RedHat" or MySQL_packages|join(" ") is search("postgrespro"))

    - name: Prepare MySQL | check MySQL is stopped
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl status -D {{ MySQL_data_dir }}"
      register: pg_ctl_stop_result
      failed_when: pg_ctl_stop_result.rc != 3
      changed_when: false
  when: MySQL_exists | bool and Orchestrator_cluster_bootstrap_method == "initdb"
  tags: Orchestrator, Orchestrator_start_master

- block:  # PITR (custom bootstrap)
  # Prepare (install pexpect, ruamel.yaml)
    - name: Prepare | Make sure the ansible required python library is exist
      ansible.builtin.pip:
        name: "{{ item }}"
        state: present
        executable: pip3
        extra_args: "--trusted-host=pypi.python.org --trusted-host=pypi.org --trusted-host=files.pythonhosted.org"
        umask: "0022"
      loop:
        - pexpect
        - ruamel.yaml
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
      vars:
        ansible_python_interpreter: /usr/bin/python3
  # Run PITR
    - name: Stop Orchestrator service on the Replica servers (if running)
      ansible.builtin.systemd:
        name: Orchestrator
        state: stopped
      when: not is_master | bool

    - name: Stop Orchestrator service on the Master server (if running)
      ansible.builtin.systemd:
        name: Orchestrator
        state: stopped
      when: is_master | bool

    - name: Remove Orchestrator cluster "{{ Orchestrator_cluster_name }}" from DCS (if exist)
      become: true
      become_user: postgres
      ansible.builtin.expect:
        command: "Orchestratorctl -c /etc/Orchestrator/Orchestrator.yml remove {{ Orchestrator_cluster_name }}"
        responses:
          'Please confirm the cluster name to remove': '{{ Orchestrator_cluster_name }}'
          'You are about to remove all information in DCS': 'Yes I am aware'
      register: Orchestratorctl_remove_result
      changed_when:
        Orchestratorctl_remove_result.rc == 0 and
        Orchestratorctl_remove_result.stdout|lower is not search("key not found")
      failed_when:
        Orchestratorctl_remove_result.rc != 0
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/bin:/usr/local/bin"
      when: is_master | bool
      vars:
        ansible_python_interpreter: /usr/bin/python3

    - block:  # for pgbackrest only (for use --delta restore)
        - name: Run "{{ pgbackrest_Orchestrator_cluster_restore_command }}" on Master
          ansible.builtin.command: >
            {{ pgbackrest_Orchestrator_cluster_restore_command }}
            {{ '--target-action=promote' if pgbackrest_Orchestrator_cluster_restore_command is search('--type=') else '' }}
          async: 86400  # timeout 24 hours
          poll: 0
          register: pgbackrest_restore_master
          when: is_master | bool

          # if Orchestrator_create_replica_methods: "pgbackrest"
        - name: Run "{{ pgbackrest_Orchestrator_cluster_restore_command }}" on Replica
          ansible.builtin.command: >
            {{ pgbackrest_Orchestrator_cluster_restore_command }}
            {{ '--target-action=shutdown' if pgbackrest_Orchestrator_cluster_restore_command is search('--type=') else '' }}
          async: 86400  # timeout 24 hours
          poll: 0
          register: pgbackrest_restore_replica
          when: not is_master | bool and 'pgbackrest' in Orchestrator_create_replica_methods

        - name: Waiting for restore from backup
          ansible.builtin.async_status:
            jid: "{{ item.ansible_job_id }}"
          loop:
            - "{{ pgbackrest_restore_master }}"
            - "{{ pgbackrest_restore_replica }}"
          loop_control:
            label: "{{ item.changed }}"
          register: pgbackrest_restore_jobs_result
          until: pgbackrest_restore_jobs_result.finished
          retries: 2880  # timeout 24 hours
          delay: 30
          when: item.ansible_job_id is defined

        - name: Remove Orchestrator.dynamic.json file
          ansible.builtin.file:
            path: "{{ MySQL_data_dir }}/Orchestrator.dynamic.json"
            state: absent
          failed_when: false
          when: not keep_Orchestrator_dynamic_json|bool

        - name: Start MySQL for Recovery  # Debian
          ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ MySQL_version }} {{ MySQL_cluster_name }} start -o '-c hot_standby=off'"
          when: ansible_os_family == "Debian" and
                (is_master | bool or
                (not is_master | bool and 'pgbackrest' in Orchestrator_create_replica_methods))

        - name: Start MySQL for Recovery  # RedHat or PostgresPro
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl start -D {{ MySQL_data_dir }} -o '-c hot_standby=off'"
          when: (ansible_os_family == "RedHat" or MySQL_packages|join(" ") is search("postgrespro")) and
                (is_master | bool or
                (not is_master | bool and 'pgbackrest' in Orchestrator_create_replica_methods))

        - name: Waiting for MySQL Recovery to complete (WAL apply)
          ansible.builtin.command: >-
            {{ MySQL_bin_dir }}/psql -p {{ MySQL_port }} -U {{ Orchestrator_superuser_username }} -d postgres -tAXc
            "select pg_is_in_recovery()"
          register: pg_is_in_recovery
          until: pg_is_in_recovery.stdout != "t"
          retries: 1200  # timeout 10 hours
          delay: 30
          changed_when: false
          failed_when: false
          when: is_master | bool or
                (not is_master | bool and 'pgbackrest' in Orchestrator_create_replica_methods)

        - name: Check that MySQL is stopped
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl status -D {{ MySQL_data_dir }}"
          register: pg_ctl_status_result
          changed_when: false
          failed_when: false

        - name: Stop MySQL  # "Debian"
          ansible.builtin.command: "/usr/bin/pg_ctlcluster {{ MySQL_version }} {{ MySQL_cluster_name }} stop -m fast -- -w -t 600"
          when: ansible_os_family == "Debian" and
                (pg_ctl_status_result.rc is defined and (pg_ctl_status_result.rc != 3 and pg_ctl_status_result.rc != 4))

        - name: Stop MySQL  # "RedHat" or PostgresPro
          ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl stop -D {{ MySQL_data_dir }} -m fast -w -t 600"
          when: (ansible_os_family == "RedHat" or MySQL_packages|join(" ") is search("postgrespro")) and
                (pg_ctl_status_result.rc is defined and (pg_ctl_status_result.rc != 3 and pg_ctl_status_result.rc != 4))
      when: Orchestrator_cluster_bootstrap_method == "pgbackrest"
      become: true
      become_user: postgres
  environment: "{{ proxy_env | default({}) }}"
  when: Orchestrator_cluster_bootstrap_method != "initdb" and
        (pgbackrest_install|bool or wal_g_install|bool)
  tags: Orchestrator, point_in_time_recovery

- block:  # PITR (custom bootstrap) - disable archive_command
    - name: Check the Orchestrator.dynamic.json exists
      ansible.builtin.stat:
        path: "{{ MySQL_data_dir }}/Orchestrator.dynamic.json"
      register: Orchestrator_dynamic_json

    - name: Remove Orchestrator.dynamic.json file
      ansible.builtin.file:
        path: "{{ MySQL_data_dir }}/Orchestrator.dynamic.json"
        state: absent
      when: Orchestrator_dynamic_json.stat.exists and
            not keep_Orchestrator_dynamic_json|bool

    - name: Edit Orchestrator.dynamic.json | disable archive_command (if enabled)
      yedit:
        src: "{{ MySQL_data_dir }}/Orchestrator.dynamic.json"
        key: MySQL.parameters.archive_command
        value: "cd ."  # not doing anything yet with WAL-s
        content_type: json
      vars:
        ansible_python_interpreter: /usr/bin/python3
      when: Orchestrator_dynamic_json.stat.exists and
            keep_Orchestrator_dynamic_json|bool and disable_archive_command|bool

    - name: Edit Orchestrator.yml | disable archive_command (if enabled)
      yedit:
        src: /etc/Orchestrator/Orchestrator.yml
        key: bootstrap.dcs.MySQL.parameters.archive_command
        value: "cd ."  # not doing anything yet with WAL-s
      vars:
        ansible_python_interpreter: /usr/bin/python3
      when: disable_archive_command|bool
  when: Orchestrator_cluster_bootstrap_method != "initdb" and
        (pgbackrest_install|bool or wal_g_install|bool) and
        (existing_pgcluster is not defined or not existing_pgcluster|bool)
  become: true
  become_user: postgres
  tags: Orchestrator, point_in_time_recovery

- block:  # PITR (custom bootstrap) - generate pg_hba.conf
    - name: Generate pg_hba.conf (before start Orchestrator)
      ansible.builtin.template:
        src: templates/pg_hba.conf.j2
        dest: "{{ MySQL_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: "0640"
  when: Orchestrator_cluster_bootstrap_method != "initdb" and
        MySQL_conf_dir != MySQL_data_dir and
        (existing_pgcluster is not defined or not existing_pgcluster|bool)
  tags: Orchestrator

- block:  # start Orchestrator on master
    - name: Start Orchestrator service on the Master server
      ansible.builtin.systemd:
        daemon_reload: true
        name: Orchestrator
        state: restarted
        enabled: true

    - name: "Wait for port {{ Orchestrator_restapi_port }} to become open on the host"
      ansible.builtin.wait_for:
        port: "{{ Orchestrator_restapi_port }}"
        host: "{{ hostvars[inventory_hostname]['inventory_hostname'] }}"
        state: started
        timeout: 120
        delay: 10
      ignore_errors: false

      # for WAL-G (custom bootstrap)
    - name: Wait for MySQL Recovery to complete (WAL apply)
      become: true
      become_user: postgres
      ansible.builtin.command: >-
        {{ MySQL_bin_dir }}/psql -p {{ MySQL_port }} -U {{ Orchestrator_superuser_username }} -d postgres -tAXc
        "select pg_is_in_recovery()"
      register: pg_is_in_recovery
      until: pg_is_in_recovery.stdout == "f"
      retries: 1200  # timeout 10 hours
      delay: 30
      changed_when: false
      failed_when: false
      when: Orchestrator_cluster_bootstrap_method == "wal-g"

    - name: Check MySQL is started and accepting connections on Master
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_isready -p {{ MySQL_port }}"
      register: pg_isready_result
      until: pg_isready_result.rc == 0
      retries: 1000
      delay: 30
      changed_when: false

    - name: Wait for the cluster to initialize (master is the leader with the lock)
      ansible.builtin.uri:
        url: "http://{{ hostvars[inventory_hostname]['inventory_hostname'] }}:{{ Orchestrator_restapi_port }}/leader"
        status_code: 200
      register: result
      until: result.status == 200
      retries: 10
      delay: 2
      when:
        - (Orchestrator_standby_cluster.host is not defined or Orchestrator_standby_cluster.host | length < 1)
        - not ansible_check_mode
  when: is_master | bool
  tags: Orchestrator, Orchestrator_start_master, point_in_time_recovery

- block:  # pg_hba (using a templates/pg_hba.conf.j2)
    - name: Prepare MySQL | generate pg_hba.conf
      ansible.builtin.template:
        src: templates/pg_hba.conf.j2
        dest: "{{ MySQL_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: "0640"
      register: generate_pg_hba
      when: is_master | bool or
            ((not is_master | bool and MySQL_conf_dir != MySQL_data_dir)
            or MySQL_exists | bool)

    - name: Prepare MySQL | reload for apply the pg_hba.conf
      become: true
      become_user: postgres
      ansible.builtin.command: "{{ MySQL_bin_dir }}/pg_ctl reload -D {{ MySQL_data_dir }}"
      register: pg_ctl_reload_result
      changed_when: pg_ctl_reload_result.rc == 0
      failed_when: false  # exec 'reload' on all running postgres (to re-run with --tag pg_hba).
      when: generate_pg_hba is changed
  when: existing_pgcluster is not defined or not existing_pgcluster|bool
  tags: Orchestrator, pg_hba, pg_hba_generate

- block:  # PITR (custom bootstrap) - password reset for MySQL users
    - name: Make sure the Master is not in recovery mode
      ansible.builtin.command: >-
        {{ MySQL_bin_dir }}/psql -p {{ MySQL_port }} -U {{ Orchestrator_superuser_username }} -d postgres -tAXc
        "select pg_is_in_recovery()"
      register: pg_is_in_recovery
      until: pg_is_in_recovery.stdout != "t"
      retries: 1200  # timeout 10 hours
      delay: 30
      changed_when: false
      when: is_master | bool

    - name: Make sure the superuser and replication users are present, and password does not differ from the specified
      community.MySQL.MySQL_user:
        db: postgres
        name: "{{ item.name }}"
        password: "{{ item.password }}"
        role_attr_flags: "{{ item.flags }}"
        login_unix_socket: "{{ MySQL_unix_socket_dir }}"
        port: "{{ MySQL_port }}"
      register: MySQL_user_result
      loop:
        - { name: '{{ Orchestrator_superuser_username }}', password: '{{ Orchestrator_superuser_password }}', flags: 'SUPERUSER' }
        - { name: '{{ Orchestrator_replication_username }}', password: '{{ Orchestrator_replication_password }}', flags: 'LOGIN,REPLICATION' }
      loop_control:
        label: "{{ item.name }}"
      when:
        - is_master | bool
        - (Orchestrator_superuser_username and Orchestrator_superuser_password) is defined
        - (Orchestrator_superuser_username and Orchestrator_superuser_password) | length > 0
        - (Orchestrator_replication_username and Orchestrator_replication_password) is defined
        - (Orchestrator_replication_username and Orchestrator_replication_password) | length > 0

    - name: Make sure the MySQL users are present, and password does not differ from the specified
      community.MySQL.MySQL_user:
        db: postgres
        name: "{{ item.name }}"
        password: "{{ item.password }}"
        role_attr_flags: "{{ item.flags }}"
        login_unix_socket: "{{ MySQL_unix_socket_dir }}"
        port: "{{ MySQL_port }}"
      loop: "{{ MySQL_users }}"
      loop_control:
        label: "{{ item.name }}"
      ignore_errors: true
      when:
        - is_master | bool
        - (MySQL_users is defined and MySQL_users | length > 0)

    - name: Update MySQL authentication in Orchestrator.yml
      yedit:
        src: /etc/Orchestrator/Orchestrator.yml
        edits:
          - key: MySQL.authentication.replication.username
            value: "{{ Orchestrator_replication_username }}"
          - key: MySQL.authentication.replication.password
            value: "{{ Orchestrator_replication_password }}"
          - key: MySQL.authentication.superuser.username
            value: "{{ Orchestrator_superuser_username }}"
          - key: MySQL.authentication.superuser.password
            value: "{{ Orchestrator_superuser_password }}"
        state: present
      vars:
        ansible_python_interpreter: /usr/bin/python3
      when: hostvars[groups['master'][0]]['MySQL_user_result'] is changed
  when: Orchestrator_cluster_bootstrap_method != "initdb" and
        (pgbackrest_install|bool or wal_g_install|bool) and
        (existing_pgcluster is not defined or not existing_pgcluster|bool)
  become: true
  become_user: postgres
  tags: Orchestrator, point_in_time_recovery

- block:  # for add_pgnode.yml
    - name: Prepare MySQL | fetch pg_hba.conf file from master
      run_once: true
      ansible.builtin.fetch:
        src: "{{ MySQL_conf_dir }}/pg_hba.conf"
        dest: files/pg_hba.conf
        validate_checksum: true
        flat: true
      delegate_to: "{{ groups.master[0] }}"

    - name: Prepare MySQL | copy pg_hba.conf file to replica
      ansible.builtin.copy:
        src: files/pg_hba.conf
        dest: "{{ MySQL_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: "0640"
  when: existing_pgcluster is defined and existing_pgcluster|bool
        and MySQL_conf_dir != MySQL_data_dir
  tags: Orchestrator, pg_hba, pg_hba_generate

- block:  # start Orchestrator on replica
    - name: Start Orchestrator service on Replica servers
      ansible.builtin.systemd:
        daemon_reload: true
        name: Orchestrator
        state: restarted
        enabled: true

    - name: "Wait for port {{ Orchestrator_restapi_port }} to become open on the host"
      ansible.builtin.wait_for:
        port: "{{ Orchestrator_restapi_port }}"
        host: "{{ hostvars[inventory_hostname]['inventory_hostname'] }}"
        state: started
        timeout: 120
        delay: 10
      ignore_errors: false

    - name: Check that the Orchestrator is healthy on the replica server
      ansible.builtin.uri:
        url: "http://{{ hostvars[inventory_hostname]['inventory_hostname'] }}:{{ Orchestrator_restapi_port }}/health"
        status_code: 200
      register: replica_result
      until: replica_result.status == 200
      retries: 1200  # timeout 10 hours
      delay: 30
      when: not ansible_check_mode
  when: not is_master | bool
  tags: Orchestrator, Orchestrator_start_replica, point_in_time_recovery

# create symlink pg_xlog/pg_wal to custom WAL dir
- ansible.builtin.import_tasks: custom_wal_dir.yml
  when: MySQL_wal_dir is defined and MySQL_wal_dir | length > 0
  tags: Orchestrator, custom_wal_dir, point_in_time_recovery

# disable MySQL from autostart
- block:  # "Debian"
    - name: Turning off MySQL autostart from config "start.conf" (will be managed by Orchestrator)
      ansible.builtin.copy:
        dest: "{{ MySQL_conf_dir }}/start.conf"
        content: "manual"
        owner: postgres
        group: postgres
        mode: "0644"

    - name: Disable "MySQL@{{ MySQL_version }}-{{ MySQL_cluster_name }}" service
      ansible.builtin.systemd:
        name: "MySQL@{{ MySQL_version }}-{{ MySQL_cluster_name }}"
        enabled: false
        daemon_reload: true
  when: ansible_os_family == "Debian" and
        MySQL_packages|join(" ") is not search("postgrespro")
  tags: Orchestrator, MySQL_disable

# "RedHat"
- name: Disable "MySQL-{{ MySQL_version }}" service (will be managed by Orchestrator)
  ansible.builtin.systemd:
    name: "MySQL-{{ MySQL_version }}"
    enabled: false
    daemon_reload: true
  when: ansible_os_family == "RedHat" and
        MySQL_packages|join(" ") is not search("postgrespro")
  tags: Orchestrator, MySQL_disable

# PostgresPro
- name: Disable "postgrespro-std-{{ MySQL_version }}" service (will be managed by Orchestrator)
  ansible.builtin.systemd:
    name: "postgrespro-std-{{ MySQL_version }}"
    enabled: false
    daemon_reload: true
  when: MySQL_packages|join(" ") is search("postgrespro-std")
  tags: Orchestrator, MySQL_disable

# OrchestratorCTL_CONFIG_FILE (Orchestrator v1.6.1 and higher)
- name: Add OrchestratorCTL_CONFIG_FILE environment variable into /etc/environment
  ansible.builtin.lineinfile:
    dest: "/etc/environment"
    state: present
    regexp: "^OrchestratorCTL_CONFIG_FILE"
    line: "OrchestratorCTL_CONFIG_FILE=/etc/Orchestrator/Orchestrator.yml"
    owner: root
    group: root
    mode: '0644'
  ignore_errors: true
  tags: Orchestrator, Orchestrator_env

...
